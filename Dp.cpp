//数塔
#include <bits/stdc++.h>
using namespace std;
int main()
{

    int a[200][200];
    int num,n;
    memset(a,0,sizeof(a));//数组初始化
    cin>>n;
    while(n--)
    {
        cin>>num;//塔的层数
        for(int i=1;i<=num;i++)
        {
            for(int j=1;j<=i;j++)
            {
            cin>>a[i][j];
            }
        }//根据题意来输入数塔的值


        for(int i=num-1;i>=1;i--)//从叶结点开始往上迭代
        {
            for(int j=1;j<=i;j++)
            {
                if(a[i+1][j]>=a[i+1][j+1])
                {
                    a[i][j]+=a[i+1][j];
                }
                else
                {
                    a[i][j]+=a[i+1][j+1];
                }

            }
          
        }
        printf("%d\n",a[1][1]);


    }



    return 0;
}
/**
 * 数字塔
 * 最简单的dp
 * HDU
 * 解题思路：解题思路：当我们只看某一局部的话，很难做出正确的选择，如：顶部9该走12还是15呢？  或者底部，10该走18还是9呢？

那么我们以DP的思想看一下这个问题，因为是从顶端往下走的，所以叶子节点为19，7，10，4，16

我们看一下2这个节点，当我走到2时，我肯定会选择19，因为19大于7，那么我们可以把2当作21，因为当我走到2的时候，就意味着接下来会走到19，

照这个思路，我们可以把倒数第二层看作21，28，19，21。这就是我们所说的，最优子结构——当前问题最优解可以通过其子问题最优解计算得出

显然 我们的子问题重叠——状态转移方程为：a[i][j]=max{a[i][j]+a[i+1][j],a[i][j]+a[i+1][j+1]},并且，每一层取值至于上层有关，即满足同级问题独立

 */
